"""
UAE configuration file parser and generator.
Handles reading, writing, and modifying Amiberry .uae configuration files.
"""

from pathlib import Path
from typing import Any


def parse_uae_config(path: Path) -> dict[str, str]:
    """
    Parse a .uae configuration file into a dictionary.

    Args:
        path: Path to the .uae configuration file

    Returns:
        Dictionary mapping configuration keys to values

    Raises:
        FileNotFoundError: If the config file doesn't exist
        ValueError: If the file cannot be parsed
    """
    if not path.exists():
        raise FileNotFoundError(f"Configuration file not found: {path}")

    config: dict[str, str] = {}

    try:
        with open(path, encoding="utf-8", errors="replace") as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()

                # Skip empty lines and comments
                if not line or line.startswith(";") or line.startswith("#"):
                    continue

                # Parse key=value pairs
                if "=" in line:
                    key, _, value = line.partition("=")
                    config[key.strip()] = value.strip()

    except Exception as e:
        raise ValueError(f"Error parsing config file at line {line_num}: {e}") from e

    return config


def write_uae_config(path: Path, config: dict[str, str]) -> None:
    """
    Write a configuration dictionary to a .uae file.

    Args:
        path: Path where the config file should be written
        config: Dictionary of configuration key-value pairs
    """
    # Ensure parent directory exists
    path.parent.mkdir(parents=True, exist_ok=True)

    with open(path, "w", encoding="utf-8") as f:
        # Write header comment
        f.write("; Amiberry configuration file\n")
        f.write("; Generated by amiberry-mcp-server\n\n")

        # Group common settings together for readability
        groups = {
            "cpu": [],
            "chipset": [],
            "memory": [],
            "floppy": [],
            "hardfile": [],
            "filesystem": [],
            "gfx": [],
            "sound": [],
            "input": [],
            "other": [],
        }

        for key, value in sorted(config.items()):
            key_lower = key.lower()
            if key_lower.startswith("cpu"):
                groups["cpu"].append((key, value))
            elif key_lower.startswith(("chipset", "collision", "blitter")):
                groups["chipset"].append((key, value))
            elif key_lower.startswith(("chip_", "fast", "bogo", "z3", "mbresmem")):
                groups["memory"].append((key, value))
            elif key_lower.startswith(("floppy", "df", "nr_floppy")):
                groups["floppy"].append((key, value))
            elif key_lower.startswith("hardfile"):
                groups["hardfile"].append((key, value))
            elif key_lower.startswith(("filesystem", "uaehf")):
                groups["filesystem"].append((key, value))
            elif key_lower.startswith("gfx"):
                groups["gfx"].append((key, value))
            elif key_lower.startswith("sound"):
                groups["sound"].append((key, value))
            elif key_lower.startswith(("input", "joyport")):
                groups["input"].append((key, value))
            else:
                groups["other"].append((key, value))

        # Write groups with section comments
        section_names = {
            "cpu": "CPU",
            "chipset": "Chipset",
            "memory": "Memory",
            "floppy": "Floppy Drives",
            "hardfile": "Hard Drives",
            "filesystem": "Filesystem",
            "gfx": "Graphics",
            "sound": "Sound",
            "input": "Input",
            "other": "Other Settings",
        }

        for group_key, items in groups.items():
            if items:
                f.write(f"; {section_names[group_key]}\n")
                for key, value in items:
                    f.write(f"{key}={value}\n")
                f.write("\n")


def modify_uae_config(path: Path, modifications: dict[str, str | None]) -> dict[str, str]:
    """
    Modify specific options in an existing .uae configuration file.

    Args:
        path: Path to the existing .uae configuration file
        modifications: Dictionary of options to modify.
                      Set value to None to remove an option.

    Returns:
        The updated configuration dictionary

    Raises:
        FileNotFoundError: If the config file doesn't exist
    """
    config = parse_uae_config(path)

    for key, value in modifications.items():
        if value is None:
            # Remove the option
            config.pop(key, None)
        else:
            # Add or update the option
            config[key] = value

    write_uae_config(path, config)
    return config


def create_config_from_template(
    output_path: Path,
    template: str = "A500",
    overrides: dict[str, str] | None = None,
) -> dict[str, str]:
    """
    Create a new configuration file from a built-in template.

    Args:
        output_path: Path where the config file should be written
        template: Template name (A500, A1200, CD32, CDTV)
        overrides: Optional dictionary of settings to override

    Returns:
        The generated configuration dictionary
    """
    templates = {
        "A500": _get_a500_template(),
        "A500P": _get_a500plus_template(),
        "A600": _get_a600_template(),
        "A1200": _get_a1200_template(),
        "A4000": _get_a4000_template(),
        "CD32": _get_cd32_template(),
        "CDTV": _get_cdtv_template(),
    }

    if template not in templates:
        raise ValueError(f"Unknown template: {template}. Available: {list(templates.keys())}")

    config = templates[template].copy()

    if overrides:
        config.update(overrides)

    write_uae_config(output_path, config)
    return config


def get_config_summary(config: dict[str, str]) -> dict[str, Any]:
    """
    Generate a human-readable summary of a configuration.

    Args:
        config: Configuration dictionary

    Returns:
        Dictionary with summarized configuration info
    """
    summary: dict[str, Any] = {}

    # CPU info
    cpu_model = config.get("cpu_model", "68000")
    cpu_speed = config.get("cpu_speed", "real")
    summary["cpu"] = {
        "model": f"68{cpu_model}" if cpu_model.isdigit() else cpu_model,
        "speed": cpu_speed,
        "24bit": config.get("cpu_24bit_addressing", "false") == "true",
    }

    # Memory
    chip_size = int(config.get("chipmem_size", "1")) * 512  # In KB
    fast_size = int(config.get("fastmem_size", "0")) * 1024  # In KB
    summary["memory"] = {
        "chip_kb": chip_size,
        "fast_kb": fast_size,
    }

    # Chipset
    chipset = config.get("chipset", "ocs")
    summary["chipset"] = chipset.upper()

    # Floppy drives
    floppies = []
    for i in range(4):
        floppy = config.get(f"floppy{i}")
        if floppy:
            floppies.append({"drive": f"DF{i}", "image": floppy})
    summary["floppies"] = floppies

    # Hard drives
    hardfiles = []
    idx = 0
    while f"hardfile2" in config or f"uaehf{idx}" in config:
        hf = config.get(f"hardfile2") or config.get(f"uaehf{idx}")
        if hf:
            hardfiles.append(hf)
        idx += 1
        if idx > 10:  # Safety limit
            break
    summary["hardfiles"] = hardfiles

    # ROM
    summary["kickstart"] = config.get("kickstart_rom_file", "")

    # Graphics
    summary["graphics"] = {
        "width": config.get("gfx_width", "640"),
        "height": config.get("gfx_height", "512"),
        "fullscreen": config.get("gfx_fullscreen_amiga", "false") == "true",
    }

    return summary


# Built-in configuration templates

def _get_a500_template() -> dict[str, str]:
    """Return A500 (OCS, 512KB chip + 512KB slow) template."""
    return {
        "cpu_model": "68000",
        "cpu_speed": "real",
        "cpu_compatible": "true",
        "cpu_24bit_addressing": "true",
        "chipset": "ocs",
        "chipset_compatible": "A500",
        "chipmem_size": "1",  # 512KB
        "bogomem_size": "2",  # 512KB slow
        "fastmem_size": "0",
        "nr_floppies": "1",
        "floppy_speed": "100",
        "floppy0type": "0",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "lores",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }


def _get_a500plus_template() -> dict[str, str]:
    """Return A500+ (ECS, 1MB chip) template."""
    return {
        "cpu_model": "68000",
        "cpu_speed": "real",
        "cpu_compatible": "true",
        "cpu_24bit_addressing": "true",
        "chipset": "ecs_agnus",
        "chipset_compatible": "A500+",
        "chipmem_size": "2",  # 1MB
        "bogomem_size": "0",
        "fastmem_size": "0",
        "nr_floppies": "1",
        "floppy_speed": "100",
        "floppy0type": "0",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "lores",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }


def _get_a600_template() -> dict[str, str]:
    """Return A600 (ECS, 2MB chip) template."""
    return {
        "cpu_model": "68000",
        "cpu_speed": "real",
        "cpu_compatible": "true",
        "cpu_24bit_addressing": "true",
        "chipset": "ecs",
        "chipset_compatible": "A600",
        "chipmem_size": "4",  # 2MB
        "bogomem_size": "0",
        "fastmem_size": "0",
        "nr_floppies": "1",
        "floppy_speed": "100",
        "floppy0type": "0",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "lores",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }


def _get_a1200_template() -> dict[str, str]:
    """Return A1200 (AGA, 68020, 2MB chip) template."""
    return {
        "cpu_model": "68020",
        "cpu_speed": "real",
        "cpu_compatible": "true",
        "cpu_24bit_addressing": "false",
        "chipset": "aga",
        "chipset_compatible": "A1200",
        "chipmem_size": "4",  # 2MB
        "bogomem_size": "0",
        "fastmem_size": "0",
        "nr_floppies": "1",
        "floppy_speed": "100",
        "floppy0type": "0",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "hires",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }


def _get_a4000_template() -> dict[str, str]:
    """Return A4000 (AGA, 68040, 2MB chip, 8MB fast) template."""
    return {
        "cpu_model": "68040",
        "cpu_speed": "max",
        "cpu_compatible": "false",
        "cpu_24bit_addressing": "false",
        "fpu_model": "68040",
        "chipset": "aga",
        "chipset_compatible": "A4000",
        "chipmem_size": "4",  # 2MB
        "bogomem_size": "0",
        "fastmem_size": "8192",  # 8MB
        "nr_floppies": "1",
        "floppy_speed": "100",
        "floppy0type": "0",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "hires",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }


def _get_cd32_template() -> dict[str, str]:
    """Return CD32 (AGA, 68020, 2MB chip, CD-ROM) template."""
    return {
        "cpu_model": "68020",
        "cpu_speed": "real",
        "cpu_compatible": "true",
        "cpu_24bit_addressing": "false",
        "chipset": "aga",
        "chipset_compatible": "CD32",
        "chipmem_size": "4",  # 2MB
        "bogomem_size": "0",
        "fastmem_size": "0",
        "nr_floppies": "0",
        "cd32cd": "true",
        "cd32c2p": "true",
        "cd32nvram": "true",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "hires",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }


def _get_cdtv_template() -> dict[str, str]:
    """Return CDTV (ECS, 68000, 1MB chip, CD-ROM) template."""
    return {
        "cpu_model": "68000",
        "cpu_speed": "real",
        "cpu_compatible": "true",
        "cpu_24bit_addressing": "true",
        "chipset": "ecs_agnus",
        "chipset_compatible": "CDTV",
        "chipmem_size": "2",  # 1MB
        "bogomem_size": "0",
        "fastmem_size": "0",
        "nr_floppies": "0",
        "cdtv": "true",
        "gfx_width": "640",
        "gfx_height": "512",
        "gfx_resolution": "lores",
        "gfx_linemode": "double",
        "sound_output": "exact",
        "sound_channels": "stereo",
        "sound_frequency": "44100",
    }
